---
layout: powershell
category: Tutorials - Powershell
title: Extend using Proxy-Functions
---

# Extending cmdlets using Proxy-Functions

A proxy function is a way to wrap an existing PowerShell function or cmdlet with customized input parameters, or settings without having to create the entire script yourself.

For example, `PSc8y` provides a generic `Update-Operation` cmdlet which updates the operation status, i.e. to `EXECUTING`, `SUCCESSFUL` or `FAILED`. Let's say you wanted to create a wrapper which only sets an operation to `FAILED` with a pre-defined failure reason (very similar to the `Cancel pending operations` button in the Cumuolocity UI).

One solution would be to create your own function however if you want all of the common parameters like `-Verbose`, `-Whatif` etc., then you would need to manually define and pass all of these parameters to the underlying `Update-Operation` cmdlet in order to provide a consistent user experience.

An alternative solution is to create a proxy-like function which just wraps an existing function with customized parameters. The parameters from the `Update-Operation` cmdlet can be copied to a new wrapper function and modified according to your use-case. The wrapper function can be auto-generated by a PowerShell module called `MetaProgramming`, which is hosted in the PowerShell module repository, PSGallery. The example below will focus on this approach.

---

## Create a wrapper (proxy-function) for `Update-Operation` to set an operation to FAILED

1. Install the MetaProgramming module

    ```powershell
    Install-Module MetaProgramming -Repository PSGallery -Scope CurrentUser
    ```

2. Import the module

    ```powershell
    Import-Module MetaProgramming
    ```

3. Create the wrapper based on `Update-operation` and save the contents to a file called `./Clear-Operation.ps1`

    ```powershell
    New-ProxyCommand `
        -Name Update-Operation `
        -RemoveParameter Status, FailureReason | Out-File "Clear-Operation.ps1"
    ```

    The the `Status` and `FailureReason` parameters were removed from the wrapper as these parameters will be set inside the function itself (not allowing the user to change them).

4. Edit `./Clear-Operation.ps1` so that it is a Function definition (instead of a script)

    Just wrap the contents of the file within a Function block. For example:

    ```powershell
    Function Clear-Operation {
        << file_contents >>
    }
    ```

5. Add the default parameter values for `Status` and `FailureReason`. These parameters will be passed to `Update-Operation` automatically

    ```powershell
    # Set pre-defined operation settings
    $PSBoundParameters['Status'] = 'FAILED'
    $PSBoundParameters['FailureReason'] = 'Manually Cancelled'
    ```

6. Save the file changes

7. Try out the new wrapper by importing it and then calling the function (very similar to calling `Update-Operation`)

    ```powershell
    # Import function using dot sourcing
    . ./Clear-Operation.ps1

    # Get a list of executing operations and pipe to the new wrapper function to clear them (set status to FAILED)
    Get-OperationCollection -Status EXECUTING | Clear-Operation
    ```

8. Check that the other common parameters are also supported (like `-WhatIf` and `-Verbose`)

    ```powershell
    Get-OperationCollection -Status EXECUTING | Clear-Operation -WhatIf -Verbose
    ```

**Full Example**

The `Clear-Operation.ps1` file contents should look similar to this:

```powershell
Function Clear-Operation {
    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact='High')]
    param(
        [Parameter(Mandatory=$true, Position=0, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)]
        [string]
        ${Id},

        [Parameter(Position=1)]
        [System.Object]
        ${Data},

        [switch]
        ${Raw},

        [Parameter(Position=2)]
        [string]
        ${OutputFile},

        [switch]
        ${NoProxy},

        [Parameter(Position=3)]
        [string]
        ${Session},

        [Parameter(Position=4)]
        [double]
        ${TimeoutSec},

        [switch]
        ${Force})

    begin
    {
        try {
            $outBuffer = $null
            if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer))
            {
                $PSBoundParameters['OutBuffer'] = 1
            }

            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Update-Operation', [System.Management.Automation.CommandTypes]::Function)

            # Set pre-defined operation settings
            $PSBoundParameters['Status'] = 'FAILED'
            $PSBoundParameters['FailureReason'] = 'Manually Cancelled'

            $scriptCmd = {& $wrappedCmd @PSBoundParameters }

            $steppablePipeline = $scriptCmd.GetSteppablePipeline()
            $steppablePipeline.Begin($PSCmdlet)
        } catch {
            throw
        }
    }

    process
    {
        try {
            $steppablePipeline.Process($_)
        } catch {
            throw
        }
    }

    end
    {
        try {
            $steppablePipeline.End()
        } catch {
            throw
        }
    }
}
<#
.Forward
.ForwardHelpTargetName Update-Operation
.ForwardHelpCategory Function

#>

```

## Review

Wrapper (proxy) functions are are usefuly way to quickly create your customized function using. 95% of the code is auto generated. In the example only 4 lines had to be modified, and the function inherits all of the functionality like piping, common parameters, etc. automatically.

## References

Additional information about using and creating proxy-functions can be found below.

* [Extending and/or Modifying Commands with Proxies](https://devblogs.microsoft.com/powershell/extending-andor-modifing-commands-with-proxies/)
* [MetaProgramming Module](https://www.powershellgallery.com/packages/MetaProgramming/1.0.0.2)
