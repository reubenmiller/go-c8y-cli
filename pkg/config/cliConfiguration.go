package config

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"strings"
	"time"

	"github.com/reubenmiller/go-c8y-cli/pkg/encrypt"
	"github.com/reubenmiller/go-c8y-cli/pkg/logger"
	"github.com/reubenmiller/go-c8y-cli/pkg/prompt"
	"github.com/reubenmiller/go-c8y-cli/pkg/totp"
	"github.com/reubenmiller/go-c8y/pkg/c8y"
	"github.com/spf13/viper"
)

var (
	// PrefixEncrypted prefix used in encrypted string fields to identify when a string is encrypted or not
	PrefixEncrypted = "{encrypted}"

	// KeyFileName is the name of the reference encryption text
	KeyFileName = ".key"
)

const (
	// SettingEncryptionCachePassphrase setting to cache the passphrase via environment variables
	SettingEncryptionCachePassphrase = "settings.encryption.cachePassphrase"
)

// CliConfiguration cli configuration settings
type CliConfiguration struct {
	viper *viper.Viper

	// Persistent settings (stored to file)
	Persistent *viper.Viper

	// Session file path
	path string

	// SecureData accessor to encrypt/decrypt data
	SecureData *encrypt.SecureData

	// Passphrase used for encrypting/decrypting fields
	Passphrase string

	// KeyFile path to the key file used to test encryption
	KeyFile string

	prompter prompt.Prompt

	// SecretText used to test the encryption passphrase
	SecretText string

	Logger *logger.Logger
}

// NewCliConfiguration returns a new CLI configuration object
func NewCliConfiguration(v *viper.Viper, secureData *encrypt.SecureData, home string, passphrase string) *CliConfiguration {
	c := &CliConfiguration{
		viper:      v,
		Passphrase: passphrase,
		SecureData: secureData,
		Persistent: viper.New(),
		prompter:   prompt.Prompt{},
		KeyFile:    path.Join(home, KeyFileName),
		Logger:     logger.NewDummyLogger("SecureData"),
	}
	c.prompter.Logger = c.Logger
	c.bindSettings()
	return c
}

func (c *CliConfiguration) bindSettings() {
	c.bindEnv(SettingEncryptionCachePassphrase, true)
}

// SetLogger sets the logger
func (c *CliConfiguration) SetLogger(l *logger.Logger) {
	c.Logger = l
	c.prompter.Logger = l
}

// ReadConfig reads the given file and loads it into the persistent session config
func (c *CliConfiguration) ReadConfig(file string) error {
	c.Persistent.SetConfigFile(file)
	return c.Persistent.ReadInConfig()
}

// CheckEncryption checks if the usuer has provided the correct encryption password or not by testing the decryption of the secret text
func (c *CliConfiguration) CheckEncryption(encryptedText ...string) (string, error) {
	secretText := c.SecretText
	if len(encryptedText) > 0 {
		secretText = encryptedText[0]
	}

	c.Logger.Infof("Checking encryption passphrase against secret text: %s", secretText)
	pass, err := c.prompter.EncryptionPassphrase(secretText, c.Passphrase, "")
	c.Passphrase = pass
	return pass, err
}

// BindAuthorization binds environment variables related to the authrorization to the configuration
func (c *CliConfiguration) BindAuthorization() error {
	c.viper.SetEnvPrefix("c8y")
	c.viper.BindEnv("host")
	c.viper.BindEnv("username")
	c.viper.BindEnv("tenant")
	c.viper.BindEnv("password")
	c.viper.BindEnv("credential.totp.secret")
	c.viper.BindEnv("credential.cookies.0")
	c.viper.BindEnv("credential.cookies.1")
	c.viper.BindEnv("credential.cookies.2")
	c.viper.BindEnv("credential.cookies.3")
	c.viper.BindEnv("credential.cookies.4")
	return nil
}

// GetUsername returns the Cumulocity username for the session
func (c *CliConfiguration) GetUsername() string {
	v := c.viper.GetString("username")

	if v != "" {
		return v
	}
	return os.Getenv("C8Y_USER")
}

// SetSessionFilePath sets the session's file path
func (c *CliConfiguration) SetSessionFilePath(v string) {
	c.path = v
}

// GetSessionFilePath returns the session file path
func (c *CliConfiguration) GetSessionFilePath() string {
	return c.path
}

// GetName returns the name of the current session
func (c *CliConfiguration) GetName() string {
	return c.viper.GetString("name")
}

// GetDescription returns the name description of the current session
func (c *CliConfiguration) GetDescription() string {
	return c.viper.GetString("name")
}

// GetTenant returns the Cumulocity tenant id
func (c *CliConfiguration) GetTenant() string {
	// check for an empty or "null" tenant name as jq outputs null if
	// a json property is not found, so the user might accidentally provide
	// null without knowing it
	if v := c.viper.GetString("tenant"); v != "" && v != "null" {
		return v
	}
	if v := c.Persistent.GetString("tenant"); v != "" && v != "null" {
		return v
	}
	return ""
}

// GetHost returns the Cumulocity host URL
func (c *CliConfiguration) GetHost() string {
	return c.viper.GetString("host")
}

// GetTOTP returns a TOTP generated by a TOTP secret (if present)
func (c *CliConfiguration) GetTOTP(t time.Time) (string, error) {
	return totp.GenerateTOTP(c.viper.GetString("credential.totp.secret"), t)
}

// CreateKeyFile creates a file used as reference to validate encryption
func (c *CliConfiguration) CreateKeyFile(keyText string) error {
	if _, err := os.Stat(c.KeyFile); os.IsExist(err) {
		c.Logger.Infof("Key file already exists. file=%s", c.KeyFile)
		return nil
	}
	key, err := os.Create(c.KeyFile)
	if err != nil {
		return err
	}

	if _, err := key.WriteString(keyText); err != nil {
		return err
	}
	return nil
}

// ReadKeyFile reads the key file used as a reference to validate encryption (i.e. when no sessions exist)
func (c *CliConfiguration) ReadKeyFile() error {

	// read from env variable
	if v := os.Getenv("C8Y_PASSPHRASE_TEXT"); v != "" && c.SecureData.IsEncrypted(v) == 1 {
		c.Logger.Infof("Using env variable 'C8Y_PASSPHRASE_TEXT' as example encryption text")
		c.SecretText = v
		c.CreateKeyFile(v)
		return nil
	}

	// read from file
	contents, err := ioutil.ReadFile(c.KeyFile)

	if err == nil {
		if c.SecureData.IsEncryptedBytes(contents) == 1 {
			c.SecretText = string(contents)
			return nil
		}
		c.Logger.Warningf("Key file is invalid or contains decrypted information")
	}

	// init key file
	passphrase, err := c.prompter.PasswordWithConfirm("new encryption passphrase", "Creating a encryption key for sessions")

	if err != nil {
		return err
	}

	c.Passphrase = passphrase

	keyText, err := c.SecureData.EncryptString("Cumulocity CLI Tool", c.Passphrase)

	if err != nil {
		return err
	}

	if err := c.CreateKeyFile(keyText); err != nil {
		return err
	}

	c.SecretText = keyText
	return nil
}

// GetEnvironmentVariables gets all the environment variables associated with the current session
func (c CliConfiguration) GetEnvironmentVariables(client *c8y.Client, setPassword bool) map[string]interface{} {
	host := c.GetHost()
	tenant := c.GetTenant()
	username := c.GetUsername()
	password := c.MustGetPassword()
	cookies := c.GetCookies()

	if client != nil {
		if client.TenantName != "" {
			tenant = client.TenantName
		}
		if client.Username != "" {
			username = client.Username
		}
		if client.BaseURL.Host != "" {
			host = client.BaseURL.Scheme + "://" + client.BaseURL.Host
		}
		if client.Password != "" {
			password = client.Password
		}
		if len(client.Cookies) > 0 {
			cookies = client.Cookies
		}
	}

	// hide password if it is not needed
	if !setPassword && len(cookies) > 0 {
		password = ""
	}

	output := map[string]interface{}{
		"C8Y_URL":      host,
		"C8Y_BASEURL":  host,
		"C8Y_HOST":     host,
		"C8Y_TENANT":   tenant,
		"C8Y_USER":     username,
		"C8Y_USERNAME": username,
		"C8Y_PASSWORD": password,
	}

	if c.CachePassphraseVariables() {
		c.Logger.Info("Caching passphrase")
		if c.Passphrase != "" {
			output["C8Y_PASSPHRASE"] = c.Passphrase
		}
		if c.SecretText != "" {
			output["C8Y_PASSPHRASE_TEXT"] = c.SecretText
		}
	}

	// add decrypted cookies
	for i, cookie := range cookies {
		output[c.GetEnvKey(fmt.Sprintf("credential.cookies.%d", i))] = fmt.Sprintf("%s=%s", cookie.Name, cookie.Value)
	}

	return output
}

// GetEnvKey returns the environment key value associated
func (c CliConfiguration) GetEnvKey(key string) string {
	return "C8Y_" + strings.ToUpper(strings.ReplaceAll(key, ".", "_"))
}

// GetCookies gets the cookies stored in the configuration
func (c CliConfiguration) GetCookies() []*http.Cookie {
	cookies := make([]*http.Cookie, 0)
	for i := 0; i < 5; i++ {
		cookieValue := c.viper.GetString(fmt.Sprintf("credential.cookies.%d", i))

		if cookieValue == "" {
			cookieValue = c.Persistent.GetString(fmt.Sprintf("credential.cookies.%d", i))
		}

		if cookieValue == "" {
			break
		}

		if v, err := c.DecryptString(cookieValue); err == nil {
			cookieValue = v
		} else {
			c.Logger.Warningf("Could not decrypt cookie. %s", err)
			continue
		}

		cookie := newCookie(cookieValue)
		if cookies != nil {
			cookies = append(cookies, cookie)
		}
	}
	return cookies
}

func newCookie(raw string) *http.Cookie {
	parts := strings.SplitN(raw, "=", 2)
	if len(parts) != 2 {
		return nil
	}

	valueParts := strings.SplitN(strings.TrimSpace(parts[1]), ";", 2)

	if len(valueParts) == 0 {
		return nil
	}

	return &http.Cookie{
		Name:  parts[0],
		Value: valueParts[0],
		Raw:   raw,
	}
}

func (c CliConfiguration) Debug() {
	c.viper.Debug()
}

// DecryptString returns the decrypted string if the string is encrypted
func (c *CliConfiguration) DecryptString(value string) (string, error) {
	if c.SecureData.IsEncrypted(value) > 0 {
		c.Logger.Infof("Decrypting data. %s", value)
	}
	value, err := c.SecureData.TryDecryptString(value, c.Passphrase)
	return value, err
}

// GetEncryptedString returns string value of a potentially encrypted field in the configuration
// If the fields starts with the encrypted prefix, then it will be decrypted using the CLI passphrase,
// otherwise the value will be returned as is.
func (c *CliConfiguration) GetEncryptedString(key string) string {
	value := c.viper.GetString(key)

	decryptedValue, err := c.DecryptString(value)
	if err != nil {
		return value
	}
	return decryptedValue
}

// SetEncryptedString encrypts and sets a value in the configuration. If the give value is empty, then the value will be read from the configuration file
func (c *CliConfiguration) SetEncryptedString(key, value string) error {
	if value == "" {
		value = c.Persistent.GetString(key)
	}

	if value == "" {
		c.Logger.Info("Password is not set so nothing to encrypt")
		return nil
	}

	var err error
	password := value
	if c.IsEncryptionEnabled() {
		password, err = c.SecureData.TryEncryptString(value, c.Passphrase)

		if err != nil {
			return err
		}
	}

	c.Persistent.Set(key, password)
	return nil
}

// WritePersistentConfig saves the configuration to file
func (c *CliConfiguration) WritePersistentConfig() error {
	file := c.viper.ConfigFileUsed()

	if file == "" {
		return fmt.Errorf("No config is being used")
	}
	c.Persistent.Set("$schema", "https://raw.githubusercontent.com/reubenmiller/go-c8y-cli/master/tools/schema/session.schema.json")

	c.SetEncryptedString("password", "")
	return c.Persistent.WriteConfig()
}

// SetAuthorizationCookies saves the authorization cookies
func (c *CliConfiguration) SetAuthorizationCookies(cookies []*http.Cookie) {
	cookieValues := make([]string, 0)

	encryptedCookies := make(map[string]string)
	var err error

	for i, cookie := range cookies {
		cookieValues = append(cookieValues, fmt.Sprintf("%s", cookie.Raw))
		c.Persistent.Set(fmt.Sprintf("credential.cookies.%d", i), "cookie")

		cookieData := cookie.Raw
		if c.IsEncryptionEnabled() {
			cookieData, err = c.SecureData.EncryptString(cookie.Raw, c.Passphrase)
			if err != nil {
				continue
			}
		}

		encryptedCookies[fmt.Sprintf("%d", i)] = cookieData
	}
	c.Persistent.Set("credential.cookies", encryptedCookies)
}

// GetPassword returns the decrypted password of the current session
func (c *CliConfiguration) GetPassword() (string, error) {
	value := c.viper.GetString("password")

	if value == "" {
		value = c.Persistent.GetString("password")
	}

	decryptedValue, err := c.DecryptString(value)
	if err != nil {
		return value, err
	}
	return decryptedValue, nil
}

// IsPasswordEncrypted return true if the password is encrypted
// If the password is empty then treat it as encrypted
func (c *CliConfiguration) IsPasswordEncrypted() bool {
	password := c.viper.GetString("password")
	return password == "" || c.SecureData.IsEncrypted(password) == 1
}

// MustGetPassword returns the decrypted password if there are no encryption errors, otherwise it will return an encrypted password
func (c *CliConfiguration) MustGetPassword() string {
	decryptedValue, err := c.GetPassword()
	if err != nil {
		c.Logger.Warningf("Could not decrypt password. %s", err)
	}
	return decryptedValue
}

// SetPassword sets the password
func (c *CliConfiguration) SetPassword(p string) {
	c.Persistent.Set("password", p)
}

// SetTenant sets the tenant name
func (c *CliConfiguration) SetTenant(value string) {
	c.Persistent.Set("tenant", value)
}

// IsCIMode return true if the cli is running in CI mode
func (c *CliConfiguration) IsCIMode() bool {
	return c.viper.GetBool("settings.ci")
}

// IsEncryptionEnabled indicates if session encryption is enabled or not
func (c *CliConfiguration) IsEncryptionEnabled() bool {
	return c.viper.GetBool("settings.encryption.enabled")
}

// GetString returns a string from the configuration
func (c *CliConfiguration) GetString(key string) string {
	return c.viper.GetString(key)
}

// GetDefaultUsername returns the default username
func (c *CliConfiguration) GetDefaultUsername() string {
	return c.viper.GetString("settings.default.username")
}

// CachePassphraseVariables return true if the passphrase variables should be persisted or not
func (c *CliConfiguration) CachePassphraseVariables() bool {
	return c.viper.GetBool(SettingEncryptionCachePassphrase)
}

func (c *CliConfiguration) bindEnv(name string, defaultValue interface{}) {
	c.viper.BindEnv(name)
	c.viper.SetDefault(name, defaultValue)
}

// DecryptSession decrypts a session (as long as the encryption passphrase has already been provided)
func (c *CliConfiguration) DecryptSession() error {
	c.SetPassword(c.MustGetPassword())
	c.SetAuthorizationCookies(c.GetCookies())
	return c.WritePersistentConfig()
}
