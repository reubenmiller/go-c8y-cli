package config

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"strings"
	"time"

	"github.com/reubenmiller/go-c8y-cli/pkg/encrypt"
	"github.com/reubenmiller/go-c8y-cli/pkg/logger"
	"github.com/reubenmiller/go-c8y-cli/pkg/prompt"
	"github.com/reubenmiller/go-c8y-cli/pkg/totp"
	"github.com/spf13/viper"
)

var (
	// PrefixEncrypted prefix used in encrypted string fields to identify when a string is encrypted or not
	PrefixEncrypted = "{encrypted}"

	KeyFileName = ".key"
)

// CliConfiguration cli configuration settings
type CliConfiguration struct {
	viper *viper.Viper

	// Persistent settings (stored to file)
	Persistent *viper.Viper

	// SecureData accessor to encrypt/decrypt data
	SecureData *encrypt.SecureData

	// Passphrase used for encrypting/decrypting fields
	Passphrase string

	// KeyFile path to the key file used to test encryption
	KeyFile string

	prompter prompt.Prompt

	// SecretText used to test the encryption passphrase
	SecretText string

	Logger *logger.Logger
}

// NewCliConfiguration returns a new CLI configuration object
func NewCliConfiguration(v *viper.Viper, secureData *encrypt.SecureData, home string, passphrase string) *CliConfiguration {
	c := &CliConfiguration{
		viper:      v,
		Passphrase: passphrase,
		SecureData: secureData,
		Persistent: viper.New(),
		prompter:   prompt.Prompt{},
		KeyFile:    path.Join(home, KeyFileName),
		Logger:     logger.NewDummyLogger("SecureData"),
	}
	c.prompter.Logger = c.Logger
	return c
}

// SetLogger sets the logger
func (c *CliConfiguration) SetLogger(l *logger.Logger) {
	c.Logger = l
	c.prompter.Logger = l
}

// ReadConfig reads the given file and loads it into the persistent session config
func (c *CliConfiguration) ReadConfig(file string) error {
	c.Persistent.SetConfigFile(file)
	return c.Persistent.ReadInConfig()
}

func (c *CliConfiguration) CheckEncryption(encryptedText ...string) (string, error) {
	secretText := c.SecretText
	if len(encryptedText) > 0 {
		secretText = encryptedText[0]
	}

	c.Logger.Infof("Checking encryption passphrase against secret text: %s", secretText)
	pass, err := c.prompter.EncryptionPassphrase(secretText, c.Passphrase, "")
	c.Passphrase = pass
	return pass, err
}

func (c *CliConfiguration) BindAuthorization() error {
	c.viper.SetEnvPrefix("c8y")
	c.viper.BindEnv("host")
	c.viper.BindEnv("username")
	c.viper.BindEnv("tenant")
	c.viper.BindEnv("password")
	c.viper.BindEnv("credential.totp.secret")
	c.viper.BindEnv("credential.cookies.0")
	c.viper.BindEnv("credential.cookies.1")
	c.viper.BindEnv("credential.cookies.2")
	c.viper.BindEnv("credential.cookies.3")
	c.viper.BindEnv("credential.cookies.4")
	return nil
}

func (c *CliConfiguration) GetUsername() string {
	v := c.viper.GetString("username")

	if v != "" {
		return v
	}
	return os.Getenv("C8Y_USER")
}

// GetTenant returns the Cumulocity tenant id
func (c *CliConfiguration) GetTenant() string {
	// check for an empty or "null" tenant name as jq outputs null if
	// a json property is not found, so the user might accidentally provide
	// null without knowing it
	if v := c.viper.GetString("tenant"); v != "" && v != "null" {
		return v
	}
	return ""
}

// GetHost returns the Cumulocity host URL
func (c *CliConfiguration) GetHost() string {
	return c.viper.GetString("host")
}

// GetTOTP returns a TOTP generated by a TOTP secret (if present)
func (c *CliConfiguration) GetTOTP(t time.Time) (string, error) {
	return totp.GenerateTOTP(c.viper.GetString("credential.totp.secret"), t)
}

func (c *CliConfiguration) CreateKeyFile(keyText string) error {
	if _, err := os.Stat(c.KeyFile); os.IsExist(err) {
		c.Logger.Infof("Key file already exists. file=%s", c.KeyFile)
		return nil
	}
	key, err := os.Create(c.KeyFile)
	if err != nil {
		return err
	}

	if _, err := key.WriteString(keyText); err != nil {
		return err
	}
	return nil
}

func (c *CliConfiguration) ReadKeyFile() error {

	// read from env variable
	if v := os.Getenv("C8Y_PASSPHRASE_TEXT"); v != "" && c.SecureData.IsEncrypted(v) == 1 {
		c.Logger.Infof("Using env variable 'C8Y_PASSPHRASE_TEXT' as example encryption text")
		c.SecretText = v
		c.CreateKeyFile(v)
		return nil
	}

	// read from file
	contents, err := ioutil.ReadFile(c.KeyFile)

	if err == nil {
		if c.SecureData.IsEncryptedBytes(contents) == 1 {
			c.SecretText = string(contents)
			return nil
		}
		c.Logger.Warningf("Key file is invalid or contains unencrypted information")
	}

	// init key file
	passphrase, err := c.prompter.PasswordWithConfirm("new encryption passphrase", "Creating a encryption key for sessions")

	if err != nil {
		return err
	}

	c.Passphrase = passphrase

	keyText, err := c.SecureData.EncryptString("Cumulocity CLI Tool", c.Passphrase)

	if err != nil {
		return err
	}

	if err := c.CreateKeyFile(keyText); err != nil {
		return err
	}

	c.SecretText = keyText
	return nil
}

func (c CliConfiguration) GetEnvironmentVariables() map[string]interface{} {
	output := map[string]interface{}{
		"C8Y_PASSPHRASE":      c.Passphrase,
		"C8Y_PASSPHRASE_TEXT": c.SecretText,
		"C8Y_PASSWORD":        c.MustGetPassword(),
	}

	// add decrypted cookies
	for i, cookie := range c.GetCookies() {
		output[c.GetEnvKey(fmt.Sprintf("credential.cookies.%d", i))] = fmt.Sprintf("%s=%s", cookie.Name, cookie.Value)
	}

	return output
}

// GetEnvKey returns the environment key value associated
func (c CliConfiguration) GetEnvKey(key string) string {
	return "C8Y_" + strings.ToUpper(strings.ReplaceAll(key, ".", "_"))
}

// GetCookies gets the cookies stored in the configuration
func (c CliConfiguration) GetCookies() []*http.Cookie {
	cookies := make([]*http.Cookie, 0)
	for i := 0; i < 5; i++ {
		cookieValue := c.viper.GetString(fmt.Sprintf("credential.cookies.%d", i))

		if cookieValue == "" {
			break
		}

		if v, err := c.DecryptString(cookieValue); err == nil {
			cookieValue = v
		} else {
			c.Logger.Warningf("Could not decrypt cookie. %s", err)
			continue
		}

		cookie := newCookie(cookieValue)
		if cookies != nil {
			cookies = append(cookies, cookie)
		}
	}
	return cookies
}

func newCookie(raw string) *http.Cookie {
	parts := strings.SplitN(raw, "=", 2)
	if len(parts) != 2 {
		return nil
	}

	valueParts := strings.SplitN(strings.TrimSpace(parts[1]), ";", 2)

	if len(valueParts) == 0 {
		return nil
	}

	return &http.Cookie{
		Name:  parts[0],
		Value: valueParts[0],
		Raw:   raw,
	}
}

func (c CliConfiguration) Debug() {
	c.viper.Debug()
}

// DecryptString returns the decrypted string if the string is encrypted
func (c *CliConfiguration) DecryptString(value string) (string, error) {
	if c.SecureData.IsEncrypted(value) > 0 {
		c.Logger.Infof("Decrypting data. %s", value)
	}
	value, err := c.SecureData.TryDecryptString(value, c.Passphrase)
	return value, err
}

// GetEncryptedString returns string value of a potentially encrypted field in the configuration
// If the fields starts with the encrypted prefix, then it will be decrypted using the CLI passphrase,
// otherwise the value will be returned as is.
func (c *CliConfiguration) GetEncryptedString(key string) string {
	value := c.viper.GetString(key)

	decryptedValue, err := c.DecryptString(value)
	if err != nil {
		return value
	}
	return decryptedValue
}

// SetEncryptedString encryptes and sets a value in the configuration
func (c *CliConfiguration) SetEncryptedString(key, value string) error {
	if value == "" {
		value = c.Persistent.GetString(key)
	}

	encryptedValue, err := c.SecureData.TryEncryptString(value, c.Passphrase)

	if err != nil {
		return err
	}

	c.Persistent.Set(key, encryptedValue)
	return nil
}

// WritePersistentConfig saves the configuration to file
func (c *CliConfiguration) WritePersistentConfig() error {
	file := c.viper.ConfigFileUsed()

	if file == "" {
		return fmt.Errorf("No config is being used")
	}
	c.Persistent.Set("$schema", "https://raw.githubusercontent.com/reubenmiller/go-c8y-cli/master/tools/schema/session.schema.json")

	c.SetEncryptedString("password", "")
	return c.Persistent.WriteConfig()
}

// SetAuthorizationCookies saves the authorization cookies
func (c *CliConfiguration) SetAuthorizationCookies(cookies []*http.Cookie) {
	cookieValues := make([]string, 0)

	encryptedCookies := make(map[string]string)

	for i, cookie := range cookies {
		cookieValues = append(cookieValues, fmt.Sprintf("%s", cookie.Raw))
		c.Persistent.Set(fmt.Sprintf("credential.cookies.%d", i), "cookie")

		encryptedValue, err := c.SecureData.EncryptString(cookie.Raw, c.Passphrase)
		if err != nil {
			continue
		}
		encryptedCookies[fmt.Sprintf("%d", i)] = encryptedValue
	}
	c.Persistent.Set("credential.cookies", encryptedCookies)
}

// GetPassword returns the decrypted password of the current session
func (c *CliConfiguration) GetPassword() (string, error) {
	value := c.viper.GetString("password")

	decryptedValue, err := c.DecryptString(value)
	if err != nil {
		return value, err
	}
	return decryptedValue, nil
}

func (c *CliConfiguration) MustGetPassword() string {
	decryptedValue, err := c.GetPassword()
	if err != nil {
		c.Logger.Warningf("Could not decrypt password. %s", err)
	}
	return decryptedValue
}

func (c *CliConfiguration) SetPassword(p string) {
	c.Persistent.Set("password", p)
}

func (c *CliConfiguration) SetTenant(value string) {
	c.Persistent.Set("tenant", value)
}

// IsCIMode return true if the cli is running in CI mode
func (c *CliConfiguration) IsCIMode() bool {
	return c.viper.GetBool("settings.ci")
}

// GetString returns a string from the configuration
func (c *CliConfiguration) GetString(key string) string {
	return c.viper.GetString(key)
}

func (c *CliConfiguration) GetDefaultUsername() string {
	return c.viper.GetString("settings.default.username")
}
